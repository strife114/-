# 第一章 进程管理

## 1.1 进程管理作用

1. 判断服务器健康状态

   内存利用率不超过70%

   CPU利用率不超过90%

2. 查看系统所有进程

3. 杀死进程



## 1.2 查看进程（静态）

```
#ps -le 
//查看系统所有进程，使用Linux标准命令格式
#ps aux
选项:
 a：显示一个终端的所有进程，除了会话引线
 u：显示进程的归属用户及内存的使用情况
 x：显示没有控制终端的进程
```

 命令输出：

1. USER:用户

2. PID:进程ID号

3. %CPU：该进程占用CPU资源百分比

4. %MEM：该进程占用物理内存百分比

5. VSZ：该进程占用虚拟内存的大小kb

6. RSS：该进程占用实际物理内存的大小kb

7. TTY：该进程在哪个终端运行

   tty1-tty7代表本地控制台终端

   tty1-tty6是本地字符界面终端

   tty7是图形终端

   pts/0-255代表虚拟终端，一般为远程连接的终端

8. STAT：进程状态

   D：不可唤醒

   R：正在运行

   S：睡眠状态，可被唤醒

   T：停止状态

   W：内存交互状态

   X：死掉的进程

   Z：僵尸进程

   <：高优先级

   N：低优先级

   L：被锁入内存

   s：包含子进程

   l：多线程

   +：后台

9. START：进程的启动时间

10. TIME：进程占用CPU的运算时间

11. COMMAND：进程名



## 1.2 查看进程（动态）

```
# top [选项]
选项：
 -d 秒数：指定top命令每隔几秒更新，默认3秒
 -b：    使用批处理模式输出，一般跟“-n”合用，用于把top命令重定向文件中
 -n 次数：指定top命令执行次数，一般和“-b”合用
 -p：    指定PID
 -s：    使top在安全模式下运行，避免在交互模式下出错
 -u 用户名：监听某个用户的进程
 
 
 # top -b -n 1 > test.txt
```

top交互模式命令：

| 动作  |                      作用                       |
| :---: | :---------------------------------------------: |
| ？或h |                      帮助                       |
|   P   |                 按cpu利用率排序                 |
|   M   |                   按内存排序                    |
|   N   |                    按PID排序                    |
|   T   |             按cpu的累计运算时间排序             |
|   k   | 按照PID号给予某个进程一个信号，一般用于终止进程 |
|   r   |          按PID号给某个进程重设优先级值          |
|   q   |                      退出                       |

命令输出第一行：

|              内容               |                             说明                             |
| :-----------------------------: | :----------------------------------------------------------: |
|            12:26:46             |                         系统当前时间                         |
|       up  1  day,  13:31        |          系统运行时间，本机已经运行一条13小时32分钟          |
|             2 users             |                      当前登录了2个用户                       |
| load average:  0.00, 0.00, 0.00 | 系统在之前一分钟，五分钟。十五分支的平均负载，如果cpu是单核，超过1就是高负载 |

注意：top第一行的信息可以使用**uptime命令**或**w命令**查看

命令输出第二行：

|        内容         |       说明       |
| :-----------------: | :--------------: |
| Tasks:   95   total | 系统中的进程总数 |
|     1  running      | 正在运行的进程数 |
|    94  sleeping     |   睡眠的进程数   |
|     0  stopped      | 正在停止的进程数 |
|      0  zombie      |    僵尸进程数    |

第三行CPU输出：

|       内容       |                          说明                          |
| :--------------: | :----------------------------------------------------: |
| Cpu(s):   0.1%us |                     用户模式占用比                     |
|      0.1%sy      |                     系统模式占用比                     |
|      0.0%ni      |                改变过优先级的用户占用比                |
|     99.7%id      |                        空闲比例                        |
|      0.1%wa      |                   等待输入输出占用比                   |
|      0.0%hi      |                  硬中断请求服务占用比                  |
|      0.1%si      |                  软中断请求服务占用比                  |
|      0.0%st      | 虚拟时间占用比，即虚拟机虚拟cpu等待实际cpu的时间百分比 |

第四行内存输出：

|           内容           |        说明        |
| :----------------------: | :----------------: |
| Mem:     625644k   total |    物理内容总量    |
|      571454k  used       | 已使用物理内存数量 |
|       53840k  free       |  空闲物理内存数量  |
|    65580k   bufffers     |    缓冲内存数量    |

第五行交换分区输出：

|          内容          |            说明            |
| :--------------------: | :------------------------: |
| Swap:    542804  total | 交换分区（虚拟内存）总大小 |
|        0k  used        |         已使用大小         |
|     524280k  free      |          空闲大小          |
|    409280k  cached     |          缓存大小          |



## 1.3 查看进程树

```
# pstree [选项]
选项：
 -p：显示进程PID
 -u：显示进程所属用户
```



## 1.4 杀死进程

### 1.4.1 查找信号

```
# kill -l
或
# man 7 signal
```

### 1.4.2 杀死进程

kill命令：

```
# kill [信号] PID
```

killall命令（杀死一类进程 ）：

```
# killall [选项] [信号] 进程名称
选项：
 -i：交互式，询问是否杀死进程
 -I：忽略进程名大小写
```

pkill命令（终端号）：

```
# pkill [选项] [信号] 进程名称
选项：
 -t 终端号：按照终端号提出用户
 
 #pkill -9 -t  pts/1
```

w命令：

```
# w
//查找我的进程
```

信号类型：

| 信号代码 | 信号名称 |                       说明                       |
| :------: | :------: | :----------------------------------------------: |
|    1     |  SIGHUP  | 让进程关闭，重新读取配置文件之后**重启**（常用） |
|    2     |  SIGINT  |          程序终止信号，用于终止前台进程          |
|    8     |  SIGFPE  |             发送致命的算术运算时发出             |
|    9     | SIGKILL  |           立即**结束**程序运行（常用）           |
|    14    | SIGALRM  |                   时钟定时信号                   |



# 第二章 工作管理

## 2.1 后台注意事项：

1. 前台指当前可以操控和执行命令的这个操作环境，后台是指工作可以自行运行但不能直接用ctrl+c终止，只能使用**fg/bg**来调用工作
2. 当前的登录终端，只能管理当前终端的工作
3. 放入后台的命令必须可以持续运行一段时间（持续运行的命令），这样才能捕捉和操作这个工作
4. 放入后台的命令不能和前台用户有交互，否则命令不能在后台执行

## 2.2后台命令管理

### 2.2.1 查看后台

```
# jobs [选项]
选项：
 -l：显示工作的PID
```



### 2.2.2 命令放入后台

1. “命令  & ”

   ```
   # tar -zcf etc.tar.gz  /etc  &
   ```

   会在后台执行

2. ctrl+z

   ```
   # tar -zcf etc.tar.gz  /etc
   进入
   ^z //ctrl+z
   ```

   命令暂停，然后放入后台



### 2.2.3 后台暂停的工作恢复前台执行

```
# fg %工作号
参数：
 %工作号：%号可以省略，但注意工作号和PID的区别
```



### 2.2.4 后台暂停的工作恢复后台执行

```
# bg %工作号
```



### 2.2.5 后台命令脱离终端运行

1. 加入/etc/rc.d/rc.local文件

2. 使用系统定时任务

3. 使用nohup命令

   ```
   # nohup [命令] &
   ```

   



## 2.3 系统资源查看

### 2.3.1 查询系统资源

```
# vmstat [刷新延时 刷新次数]

# vmstat 1 3
```

procs：进程信息字段

1. r：等待运行的进程数
2. b：不可唤醒的进程数

memory：内存信息字段

1. swpd：虚拟内存的使用kb
2. free：空闲的内存容量kb
3. buff：缓冲的内存容量kb
4. cache：缓存的内存容量kb

swap：交换分区的信息字段

1. si：从磁盘中交换到内存中数据的数量
2. so：从内存中交换到磁盘中数据的数量

io：磁盘读写信息的字段

1. bi：从块设备读入数据的总量，单位块
2. bo：写到块设备的数据的总量

system：系统信息字段

1. in：每秒被终端的进程次数
2. cs：每秒钟进行的时间切换次数

CPU：cpu信息字段

1. us：非内核进程消耗cpu运算时间的百分比
2. sy：内核进程消耗cpu运算时间的百分比
3. id：空闲cpu的占用比
4. wa：等待I/O所消耗的cpu百分比
5. st：被虚拟机所盗用的cpu百分比



### 2.3.2 开机时内核信息

```
# dmesg | grep CPU
//查看CPU信息
# dmesg | grep eth0
//显示第一块网卡的信息
```



### 2.3.3 查看内存使用状态

```
# free [-b|-k|-m|-g]
选项：
 -b：以字节为单位
 -k：以kb为单位
 -m：以mb为单位
 -g：以gb为单位
```



### 2.3.4 查看cpu基本信息

```
#cd /proc/cpuinfo
```



### 2.3.5 查看内核基本信息

```
# uname [选项]
选项：
 -a： 查看系统所有相关信息
 -r： 查看内核版本
 -s： 查看内核名称
```



### 2.3.6 查看系统位数

```
# file /bin/ls
//主要判断系统命令的位数
```



### 2.3.7  Linux系统发行版本

```
# lsb_release -a
```



## 2.4 定时任务

### 2.4.1 一次性执行at

```
# at [选项] 时间
选项：
 -m：当at工作完成后，无论是否命令有输出，都用email通知执行at的用户
 -c 工作号：显示该at工作的实际内容
 
 at支持的时间格式
 HH:MM       02:30
 HH:MM YYYY-MM-DD   02:30 2013-07-27
 HH:MM[am|pm] [month] [date]   02:30  July 25
 //小时:分钟[上午|下午] [月] [日]

 HH:MM[am|pm] + [minutes|hours|days|weeks]
 //now + 5 minutes
 // 05am +2 hours
```



#### at的访问控制：

1. 白名单/etc/at.allow

   如果系统中有/etc/at.allow文件，那么只有写入/etc/at.allow文件中的用户才可以使用at命令

2. 黑名单/etc/ad.deny

   如果系统中有/etc/at.deny文件，那么只有写没有入/etc/at.deny文件中的用户才可以使用at命令

注意：

如果没有这两个文件，那么只有root用户能够使用



#### 查询和删除

```
# atq 
//查询

# atrm [工作号]
//删除
```





### 2.4.2 循环执行crontab

**crontab访问控制**

1. 白名单/etc/cron.allow

   如果系统中有/etc/cron.allow文件，那么只有写入/etc/cron.allow文件中的用户才可以使用at命令

2. 黑名单/etc/cron.deny

   如果系统中有/etc/cron.deny文件，那么只有写没有入/etc/cron.deny文件中的用户才可以使用at命令

注意：

1. 如果没有这两个文件，那么只有root用户能够使用
2. Linux默认只有/etc/cron.deny文件



```
# crontab [选项]
选项：
 -e：编辑定时任务
 -l：查询任务
 -r：删除当前用户所有的任务，删除一个用“crontab -e”
 -u 用户名：修改或删除其他用户的任务，只有root使用
```

**crontab -e的编辑界面**

```
*****  执行的任务（命令）
```

|  项目   |       含义       |          范围           |
| :-----: | :--------------: | :---------------------: |
| 第一个* | 每小时中第几分钟 |          0-59           |
| 第二个* |   每天第几小时   |          0-23           |
| 第三个* |    每月第几天    |          1-31           |
| 第四个* |    每年第几月    |          1-12           |
| 第五个* |    每周星期几    | 0-7（0和7都代表星期日） |

**特殊符号：**

| 特殊符号 |                             含义                             |
| :------: | :----------------------------------------------------------: |
|    *     |  代表任何时间，比如第一个*代表一小时每分钟都执行一次的意思   |
|    ,     | 代表不连续的时间，比如“0 8,12,16 * * *”代表每天的8点0分，12点0分，16点0分都执行一次 |
|    -     | 代表连续的时间，比如“0 5 * * 1-6”代表在周一到周六的凌晨五点0分 |
|   */n    | 代表每隔多久执行一次，比如“*/10 * * * *”代表每十分钟执行一次命令 |

**注意事项：**

1. 六个选项不能为空
2. crontab定时任务最小有效时间是分钟，最大为月
3. 日期和星期不用再一条定时任务中出现
4. 使用绝对路径



### 2.4.3 crontab配置文件

使用配置文件/etc/crontab不会被用户身份限制，可以手工修改

**配置方法:**

1. 将执行文件复制到/etc/cron.{daily,weekly,monthly}目录中，文件会自动执行，比如我想让它每周运行，就复制到/etc/cron.weekly/目录中

2. 修改/etc/crontab文件

   ```
   * * * * * 用户名 执行文件 文件的绝对路径
   ```

   



### 2.4.4 anacron

**作用：**

 因为关机后无法执行的定时任务会在开机后由anacron重新执行



**执行原理：**

anacron会根据/var/spool/anacron/目录中存在的cron.{daily,weekly,monthly}目录中保存的anacron上次执行的时间，去跟当前时间做比较，如果超过指定时间差（一般七天或一个月），anacron会觉得漏掉了一些任务没有执行，会介入执行漏掉的任务



**命令：**

```
# anacron [选项] [工作名]
选项：
 -s：开始工作，依据/etc/anacrontab文件中设定的延迟时间
 -n：立即执行所有工作，忽略延迟时间
 -u：更新/var/spool/anacron/cron{daily,weekly,monthly}文件中的时间戳
 
参数：
 工作名： 依据/etc/anacrontab文件中定义的文件名
```



**配置文件：**

```
RANDOM_DELAY=45
//最大随机延迟

START_HOURS_RANGE=3-22
//anacron的执行时间范围是3：00-22：00

1  5  cron.daily   nice run-parts /etc/cron.daily
//天数 强制延迟 工作名称  实际执行的命令
```

nice命令指定默认优先级

**run-parts**是一个Linux自带的shell脚本，保存在/usr/bin/run-parts，可以把这些/etc/cron.{daily,weekly,monthly}目录的文件依次执行
