# 第一章  shell基础

## 1.1  shell概述

是一个命令解释器，负责解释二进制跟代码的转换，可以利用Linux命令组成脚本减少运维压力

shell类别：Bourne Again(Bash)

/etc/shells      Linux支持的shell
1、什么是 Shell ?
一般说的 Shell 都是指命令行 shell （command line shell，CLI），属于一种应用程序，相当于 **Linux 中的命令解释器**；
Shell 把命令或程序传递给操作系统（如Linux），调用系统内核来执行，是**用户使用操作系统的桥梁**；
过去命令行 Shell 是类Unix 系统中唯一的用户接口，后来出现了图形化的用户接口（graphical user interfaces ，GUIs），如 Ubuntu 操作系统下的图形界面；
Shell 既是一种**命令语言**，可以交互式的解释和执行用户输入的命令；
Shell 又是一种**解释型的程序设计语言**，有各种变量和参数，及循环和分支等复杂的流程控制结构；

## 1.2  echo命令

   

```
#echo [选项] [输出内容]
选项：
 -e：支持反斜线控制字符转换
 -n：取消输出后的换行符号
```

在echo命令使用了”-e“选项，则支持控制字符

| 控制字符 | 作用                                                |
| :------: | --------------------------------------------------- |
|   \\\    | 输出\本身                                           |
|    \a    | 输出警告声音                                        |
|    \b    | 退格键                                              |
|    \c    | 取消输出行来的换行符，功能跟“-n”一致                |
|    \e    | ESCAPE键                                            |
|    \f    | 换页符                                              |
|    \n    | 换行符                                              |
|    \r    | 回车键                                              |
|    \t    | 制表符，也就是tab键，两个字符之间有空位             |
|    \v    | 垂直制表符                                          |
|  \0nnn   | 按八进制ascii码表输出字符，0为数字零，nnn是八进制数 |
|   \xhh   | 按十六进制ascii码表输出字符，hh是两位十六进制数     |

字符颜色输出：

```
#echo  -e "\e[1;颜色码  字符   \e[0m"

例：
#echo  -e  "\e[1;30m  abcd  \e[0m"
```

\e[1;      代表开始       \e[0m    代表结束

| 字体颜色 | 背景颜色 |
| -------- | -------- |
| 30m=黑色 | 40m=黑色 |
| 31m=红色 | 41m=红色 |
| 32m=绿色 | 42m=绿色 |
| 33m=黄色 | 43m=黄色 |
| 34m=蓝色 | 44m=蓝色 |
| 35m=洋红 | 45m=洋红 |
| 36m=青色 | 46m=青色 |
| 37m=白色 | 47m=白色 |



## 1.3 脚本执行程序

```
#!/bin/bash   //标识以下程序为shell
echo "1111111111111111"
```

脚本执行程序方法：

1. 赋予执行权限，通过绝对路径或相对路径执行

```
#/root/hello.sh  绝对
#./hello.sh   相对

```

2. 通过Bash调用执行脚本

3. ```
   #bash  hello.sh
   ```



## 1.4 bash基本功能

 



### 1.4.1 历史命令

查看：

```
#history  [选项] [历史命令保存文件]
选项：
 -c：清空历史命令
 -w：把缓存中的历史命令写入历史命令保存文件，如果不指定，会默认放入历史保存文件~/.bash_historty中
```

history命令查看的历史和~/.bash_history文件中保存的命令不一样，只有用户注销后缓存的命令会保存在~/.bash_history文件中

/etc/profile 配置文件可修改**历史命令保存条数**（HISTSIZE）



### 1.4.2 调用方式

1. 上下箭头
2. “!n” 重复执行第n条命令
3. “!!” 重复执行上一条命令
4. “!字串” 重复执行最后一条以该字串开头的命令
5. “!$” 重复上一条命令的最后一个参数



### 1.4.3 bash常用快捷键

| ctrl+A |         移动到命令行开头         |
| :----: | :------------------------------: |
| ctrl+E |         移动到命令行结尾         |
| ctrl+C |         强制终止当前命令         |
| ctrl+L |      清屏，相当于clear命令       |
| ctrl+U |     删除或剪切光标之前的命令     |
| ctrl+K |     删除或剪切光标之后的内容     |
| ctrl+Y |   粘贴ctrl+U或ctrl+K剪切的内容   |
| ctrl+R |       在历史命令总搜索内容       |
| ctrl+D |           退出当前终端           |
| ctrl+Z | 暂停并放入后台，牵扯工作管理内容 |
| ctrl+S |           暂停屏幕输出           |
| ctrl+Q |           恢复屏幕输出           |



### 1.4.4 bash标志输入输出

|  设备  | 设备文件名  | 文件描述符 |     类型     |
| :----: | :---------: | :--------: | :----------: |
|  键盘  | /dev/stdin  |     0      |   标志输入   |
| 显示器 | /dev/stdout |     1      |   标志输出   |
| 显示器 | /dev/stderr |     2      | 标志错误输出 |



### 1.4.5 输出重定向

| 类型                   | 符号                   | 作用                                                     |
| ---------------------- | ---------------------- | -------------------------------------------------------- |
| 标准输出重定向         | 命令  >  文件          | 以覆盖方式，把命令的运行结果输出到指定文件或设备中       |
|                        | 命令  >>  文件         | 以追加方式，把命令的运行结果输出到指定文件或设备中       |
| 标准错误输出重定向     | 错误命令      2>文件   | 以覆盖方式，把命令的运行错误结果输出到指定文件或设备中   |
|                        | 错误命令      2>>文件  | 以追加方式，把命令的运行错误结果输出到指定文件或设备中   |
| 正确与错误输出同时保存 | 命令  >>  文件  2>&1   | 以追加方式，把正确输出和错误输出都保存到同一个文件或设备 |
|                        | 命令  **&>>**文件      | 以追加方式，把正确输出和错误输出都保存到同一个文件或设备 |
|                        | 命令>>文件1   2>>文件2 | 把正确输出保存在文件1，错误输出保存在文件2               |

注意：错误输出没有空格（2>>文件），否则命令报错



### 1.4.6 输入重定向

 **统计命令：**

```
#wc  [选项] [文件名]
选项：
 -c：统计字节数
 -w：统计单词数
 -l：统计行数
```

<



### 1.4.7 多命令顺序执行

| 多命令执行符 | 格式               | 作用                                                         |
| ------------ | ------------------ | ------------------------------------------------------------ |
| ;            | 命令1 ;  命令2     | 多个命令顺序执行，命令之间没有任何逻辑关系                   |
| &&           | 命令1 && 命令2     | 当命令1执行($?=0)命令2才能执行，命令1报错($? !=0)命令2不执行 |
| \|\|         | 命令1  \|\|  命令2 | 当命令1执行错误($? !=0)，命令2才能执行($?=0)当命令1执行正确，命令2跳过 |



**(查找)行提取命令grep**

```
#grep [选项] "搜索内容"  文件名
选项：
 -A 数字：  列出符合条件的行，并列出后续的n行
 -B 数字：  列出符合条件的行，并列出前面的n行
 -c：      统计找到符合条件的字符串的次数
 -i：      忽略大小写
 -n：      输出行号
 -v：      反向查找
 --color=auto     搜索出的关键字用颜色显示
 
```



### 1.4.8 bash特殊符号

| 符号 | 作用                                                         |
| ---- | ------------------------------------------------------------ |
| ' '  | 单引号，在其中的所有符号和字符，会失去其自身的特殊含义，成为普通字符串 |
| " "  | 双引号，在双引号中特殊符号都没有特殊含义，但“$”、“`”、“\”例外，拥有“调用变量的值”、“引用命令”和“转义符”的特殊含义 |
| ``   | 反引号，括起来的内容变为系统命令。在bash中优先执行           |
| $()  | 与反引号作用一样                                             |
| （） | 用于一串命令执行时，（）中的命令会在子shell中运行            |
| {}   | 用于一串命令执行时，{}中的命令会在当前shell中执行，也可以用于变量变形与替换 |
| []   | 用于变量判断                                                 |
| #    | 注释                                                         |
| $    | 调用变量的值，如果需要name的值，需要$name调用                |
| \    | 转义符，跟在\之后的的特殊符号失去特殊含义，变为普通字符      |

```
name=lm
echo  $name
结果：lm
```

注意：

{}最后一个命令要用分号，第一个命令和左括号之间必须要有一个空格

()和{}中括号里面的某个命令的重定向只影响该命令，括号外的重定向则影响括号里的所有命令

但()和{}作用不大



## 1.5 变量

### 1.5.1 变量命名规则

1. 由**字母、数字、下划线组成，不能以数字开头**
2. 变量**默认类型为字符串型**，如果进行数值运算，指定变量类型为数值型
3. 变量用等号连接值，等号左**右两侧不能有空格**
4. 如果**值有空格，需要使用单引号或双引号包括**
5. 在变量值里面，可以使用“\”转义符
6. 如果需要增加变量的值，那么可以进行变量值的叠加。不过变量需要使用双引号包含**“$变量名”**或用**${变量名}**

```shell
#text=123
#text="$text"456  或  text=${text}456
echo  $text
123456
```

7. 如果是吧命令的结果作为变量值赋予变量，则需要使用**反引号**或**$()**包含

   ```
   #test=$(date)
   #echo $test
   2033年 10月 21日  星期一  20：11：11 CST
   ```

8. 环境变量名建议大写，用于区分



### 1.5.2 变量的分类

1. 用户自定义变量：由用户自定义变量名和值
2. 环境变量：分为用户自定义环境变量和系统环境变量，主要保存的是和系统操作环境相关的数据
3. 位置参数变量：主要用于向脚本当中传递参数或数据的，变量名和作用都是固定的
4. 预定义变量：bash中定义好的变量，变量名不能自定义，作用也是固定的



### 1.5.3 用户自定义变量

**查看变量：**

```
# set [选项]
选项:
 -u: 调用未声明变量时会报错（默认无提示）
 -x: 在命令执行前，先输出一次命令
```

有些环境变量set看不到可以用env命令，但env命令不支持查找用户自定义变量,总的来说set可以查看几乎所有变量，而env只能查看环境变量

** **

```
#unset  变量名
```

用户自定义变量只能在本地bash使用，环境变量通用

### 1.5.4 环境变量

设置变量:

```
# export  变量名(大写)="变量值"
//export只是declare命令的简易写法
```

删除变量：

```
#unset gender
或
#env | grep gender
```

注：只允许删除用户自定义的环境变量



**PATH环境变量：系统查找命令的路径**

PATH变量值是用”：“分割的路径，这些路径解释系统查找命令的路径

```
PATH=/usr/lib64/qt-3.3/bin:.usr/local/sbin:/usr/local/bin
```

查询：

```
echo $PATH
```

增加PATH变量值(临时生效)：

```
#PATH="$PATH":目录路径(/root/sh)
```

**永久生效：vim /etc/profile**

**PS1变量：定义命令提示符**

系统默认格式：

```
[\u@\h \w]\$  PS1=' [\u@\h \w]\$ '  临时生效
[root@localhost usr/ddd]#
```

PS1变量选项：

1. \d：显示日期，格式：星期  月  日
2. \H：显示完整主机名，例如：localhost.localdomain
3. \h：显示简写主机名，如默认主机名：localhost
4. \t：显示24小时时间，格式：HH:MM:SS
5. \T：显示12小时时间，格式：HH:MM:SS
6. \A：显示24小时时间，格式：HH:MM
7. \@：显示12小时时间，格式：HH:MM am/pm
8. \u：显示当前用户名
9. \v：显示Bash版本信息
10. \w：显示当前所在目录的完整名称
11. \W：显示当前所在目录的最后一个目录
12. \\#：执行的第几个命令
13. \\$：提示符

**永久生效：/etc/bashrc**



LANG语系变量：定义主语系变量

```
#LANG=zh_CN.UTF-8 //本地终端不支持中文语系
#echo  $LANG
zh_CN.UTF-8 
```

查询当前系统默认语系：

```
#locale
```

Linux支持语系：

```
#locale  -a  | more
```



### 1.5.5位置参数变量

| 位置参数变量 | 作用                                                         |
| ------------ | ------------------------------------------------------------ |
| $n           | n为数字，$0代表命令本身，$1-9代表第一到九的九个参数，十以上的参数需要用大括号包含，如${10} |
| $*           | 代表命令行中所有的参数，$*把所有参数看成一个整体             |
| $@           | 代表命令行中所有参数，不过 $@把每个参数区分对待              |
| $#           | 代表命令行中所有参数个数                                     |

$n:

```
#vi  ./aaa.sh //适合程序员使用
#!/bin/bash

a=$1
b=$2
sum=$(($a+$b))//$(())代表双括号里面的是数字
echo $sum

echo $$0 //./aaa.sh

#.aaa.sh  110  220
330
```

$*和$@:

```
#./bbb.sh  1 2 3 4
#!bin/bash

for i in "$*"
 do
  echo $i
 done
 
 结果：1234 //循环了一次
 
for y in "$@"
 do
  echo $y
 done
 
 结果：1
      2
      3
      4 //循环了四次
```



### 1.5.6预定义变量

| 预定义变量 | 作用                                                         |
| ---------- | ------------------------------------------------------------ |
| $?         | 最后一次执行命令的返回状态，值为0，代表上一个命令执行成功，非零则执行不成功 |
| $$         | 当前进程的进程号（PID）                                      |
| $!         | 后台运行的最后一个进程的进程号                               |

$?:

```
#cat aaa
#echo $?
0
```



## 1.6 提示接收键盘输入read

命令：

```
# read [选项] [变量名]
选项：
 -p：       等待read输入时，输出提示信息
 -t 秒数：   read会一直等待用户输入，使用此选项可以指定等待时间
 -n 字符数： read只接受指定的字符数，就会执行
 -s：       隐藏输入的数据，适用机密信息的输入
```

例子：

```
#!/bin/bash
read -t 30 -p "Please input your name:"  name  //适合用户使用
echo "Name is $name"
```

```
$!/bin/bash
read -n 1 -t 30 "please select a gender[M/F]: "  aaa
```



## 1.7 declare声明变量类型

所有变量**默认字符串型**

命令：

```
# declare [+/-]  [选项]  变量名
选项：
 -：给变量设置类型
 +：取消变量设置类型
 -a：设置变量为数组型
 -i：设置变量为整型
 -r：设置变量为只读变量 //只读变量不能修改不能删除不能通过+r取消只读属性
 -x：将变量说明为环境变量
 -p：显示指定变量的设置类型
```

整型例：

```
#a=1
#b=2
# declare -i  c=$a+$b  //3
#echo $c//3
```

数组例：

```
# name[0]="asd"
# name[1]="zxc"
# name[2]="qwe"
# echo ${name}
asd
# echo ${name[*]}
asdzxcqwe
```

环境例：

```
# declare -x test=123
//export只是declare命令的简易写法
```



## 1.8 数值运算

declare命令：

```
#a=1
#b=2
# declare -i  c=$a+$b  //3
#echo $c//3
```

expr运算器：

```
#a=1
#b=2
#d=$(expr  $aa + $bb)
#echo $d//3
```

$((运算式))：

```
#a=1
#b=2
#d=$(($a+$b))
echo $d//3
```

四则运算基本判断：

```
#!/bin/bash
read -t 30 -p "Please input your num1:"  num1
read -t 30 -p "Please input your num2:"  num2
read -n 1 -t 30 "please select a gender[+*/]:"oper
echo -e "\n"
["$oper" == "+"] && echo "$(($num1+$num2))" && exit
["$oper" == "-"] && echo "$(($num1-$num2))" && exit
["$oper" == "*"] && echo "$(($num1*$num2))" && exit
["$oper" == "/"] && echo "$(($num1/$num2))" && exit
echo "请输入正确运算符"
```

exit  错误值

退出程序并返回错误值

其值会被赋入到$?

```
exit  12
报错后
# echo $?
12
```



## 1.9 变量测试与内容置换

| 变量置换方式 | 变量y没有值 | y为空值 | y有值 |
| ------------ | ----------- | ------- | ----- |
| x=${y-新值}  | x=新值      | x为空   | x=$y  |

**注：变量不存在和变量值为空是两个概念**



## 2.0 环境变量配置文件

### 2.0.1 source命令

```
# source  配置文件      
或
# . 配置文件   //调用环境变量配置文件，让环境变量生效
```

在Linux系统登录是主要生效的环境变量配置文件：

1.  /etc/profile
2.  /etc/profile.d/*.sh
3.  ~/.bash_profile
4.  ~/.bashrc
5.  /etc/bashrc

/etc下的对所有用户永久生效，家目录只对当前用户生效



### 2.0.2 环境变量调用过程

![](D:\自诩\yun\linux\shell照片\屏幕截图 2022-06-30 120303.png)



![](D:\自诩\yun\linux\shell照片\屏幕截图 2022-06-30 121107.png)

红色：正常登录

蓝色：非登录（不使用密码登录，一般为切换普通用户或开启子bash）



### 2.0.3 /etc/profile默认环境变量

![](D:\自诩\yun\linux\shell照片\profile默认环境变量.png)

###  2.0.4 由 /etc/profile调用/etc/profile.d/*.sh     

所欲以.sh结尾的文件都会呗/etc/profile文件调用，常用lang.sh文件，这个文件会调用/etc/sysconfig/il8n文件



### 2.0.5 由/etc/profile调用~/.bash_profile文件

主要调用：

1. ~/.bashrc文件
2. 在PATH变量后加入“:$HOME/bin”

### 2.0.6  由~/.bash_profile调用~/bashrc文件

主要调用：

1. 定义默认别名
2. 调用/etc/bashrc



### 2.0.7 由~/bashrc调用/etc/bashrc

1. PS1变量
2. umask
3. PATH变量
4. 调用/etc/profile.d/*.sh 文件



### 2.0.8 退出时生效的环境变量配置文件

~/.bash_logout，这个文件默认没有写入任何内容，如果需要退出登录时执行一些操作，可以写入

### 2.0.9 其他配置文件

~/.bash_history：历史命令保存文件

/etc/issue：shell登录前的信息（欢迎信息）

### 2.0.10  /etc/issue shell登录信息

作用:用户在**本地终端**登录成功前的欢迎信息

| 转义符 | 作用                 |
| ------ | -------------------- |
| \d     | 当前系统日期         |
| \s     | 操作系统名称         |
| \l     | 登录的终端号         |
| \m     | 硬件体系结构         |
| \n     | 主机名               |
| \o     | 域名                 |
| \r     | 内核版本             |
| \t     | 当前系统时间         |
| \u     | 当前登录用户的序列号 |

例：

```
CentOS release 7.0(Final)
Kernel \r on an \m
```



另外，/etc/issue.net是远程登录前的欢迎信息文件，但其是否显示取决于ssh的配置文件

/etc/ssh/sshd_config

```
#Banner none    取消注释将none写为/etc/issue.net
Banner /etc/issue.net
```

但其不支持转义符



etc/motd

作用：用户输入用户名密码后的欢迎信息，不论本地还是远程都可以显示



### 2.0.11 Bash快捷键

查询所有快捷键：

```
# stty -a   
```

定义快捷键：

```
# stty 关键字 快捷键
```

例：

```
# stty intr ^p    定义ctrl+p快捷键为强制终止
```



------



# 第二章  shell编程

## 2.1 正则

正则表达式和通配符的区别：正则表达式用来在文件种匹配符合条件的字符串，通配符用来匹配符合条件的文件名



### **(查找)行提取命令grep**

```
#grep [选项] "搜索内容"  文件名
选项：
 -A 数字：  列出符合条件的行，并列出后续的n行
 -B 数字：  列出符合条件的行，并列出前面的n行
 -c：      统计找到符合条件的字符串的次数
 -i：      忽略大小写
 -n：      输出行号
 -v：      反向查找
 --color=auto     搜索出的关键字用颜色显示
 
```



### 2.1.1 基础正则表达式

| 元字符    | 作用                                                         |
| --------- | ------------------------------------------------------------ |
| *         | 星号前一个字符匹配0次或无数次                                |
| .         | 匹配除了换行符之外任意**一个**字符                           |
| ^         | 匹配以某个字符为开头的行                                     |
| $         | 匹配以某个字符为结尾的行                                     |
| []        | 匹配中括号中指定的任意**一个**字符                           |
| [^]       | 匹配中括号的字符以外的任意**一个**字符                       |
| \         | 转义符                                                       |
| \\{n\\}   | 表示其前面的字符恰好出现n次，例如：[0-9]\\{4\\}表示4位及以上的数字,如果是grep -E 则不需要反斜杠 |
| \\{n,\\}  | 表示其前面的字符出现不少于n次，例如：[0-9]\\{4\\}匹配4位数字,如果是grep -E 则不需要反斜杠 |
| \\{n,m\\} | 表示其前面的字符至少出现n次，最多出现m次，例如：[0-9]\\{4,8\\}匹配4到8位数字,如果是grep -E 则不需要反斜杠 |

*例：

```
# grep  "a*"  abe.txt  //a*无意义
# grep  "aaa*" abe.txt  //匹配包含“aa”或大于“aa”（aaa）的
```

.例：

```
# grep "s..d"  test.txt
said
soid

```

^例：

```
# grep "^M" test.txt
MR
MC
```

$例:

```
# grep "M$" tex.txt
SM
CM
```

排除空白行：

```
# grep -v "^$" test.txt  
```

[0-9]：

```
grep  "[0-9]" test.txt    //正则是包含匹配所以全部列出
1123asdas
asd44123
```

以小写字母开头（^[a-z]：

```
#grep  "^[a-z]"  test.txt
a123sf
zdfsd2
```

\\{n\\}例：

```
# grep "a\{3\}" test.txt  /搜索a字符重复了三次的
```

\\{n,\\}例：

```
# grep "a\{3,\}" test.txt  //搜索a字符至少重复三次以上的
```

\\{n,m\\}例：

```
#grep "a\{3,8\}" test.txt //搜索a字符重复三次以上八次以下的
```

匹配手机号码：

```
[1][3-8][0-9]\{9\}
```

匹配邮箱：

```
grep -E "[0-9a-zA-Z_]+@[0-9a-zA-Z_]+(\.[0-9a-zA-Z_]+){1,3}"  test.txt

sc@/163.com
```

查询/etc/passwd的普通用户：

```
# grep -v "root" /etc/passwd | grep "bin/bash"
命令一的结果作为命令二的查找对象
```



### 2.1.2 扩展正则表达式

egrep命令或grep -E来支持扩展正则 

| 扩展元字符 | 作用                                                         |
| ---------- | ------------------------------------------------------------ |
| +          | 前一个字符匹配一次或多次，例“go+gle”匹配"gogle"、“google”、“gooogle” |
| ？         | 前一个字符匹配0次或1次，例“sa?id”匹配“said”、“sid”           |
| \|         | 匹配两个或多个分支选项，例“was\|his”会匹配既包含was的行，又匹配包含his的行 |
| ()         | 匹配其整体位一个字符，即模式单元。例“（dog）+”会匹配“dogdog”、“dogdogdog”，“hello （world\|earth）”会匹配“hello world”或“hello earth” |



## 2.2 字符截取和替换命令

### 2.2.1 cut列提取命令

```
# cut [选项] 文件名
选项：
 -f 列号：提取第几列
 -d 分隔符：按照指定分隔符分割列
 -c 字符范围：不依赖分隔符区分列，而通过字符范围（行首为0）来进行字段提取 “n-”表示从n个字符到行尾，“n-m”表示从n个字符到m个字符，“-m”表示从第一个字符到第m个字符
```

提取普通用户名例：

```
# grep "/bin/bash" /etc/passwd | grep -v "root" | cut -d ":" -f 1
```

注意：

cut命令默认分隔符是制表符，也就是tab键,而且不是使用-d的空格作为分隔符



### 2.2.2 awk之printf格式化输出

```
# printf '输出类型输出格式'  输出内容
输出类型：
 %ns：输出字符串，n是数字代表输出几个字符
 %ni：输出整数，n是数字代表输出几个数字
 %m.nf：输出浮点数，m和n是数字，代表输出的整数位数和小数位数，例“%8.2f”代表共输出八位数，其中两位小数，六位整数
 
输出格式：
 \a：输出警告声音
 \b：输出退格键，也就是Backspace键
 \f：清除屏幕
 \n：换行
 \r：回车
 \t：水平输出退格键
 \v：垂直输出退格键
```

输出文件内容例：

```
# printf '%s' $(cat student.txt) //需要调用系统命令
```



### 2.2.3 字符串处理之awk（列提取）

**awk命令格式：**

```
# awk '条件1{动作1}  条件2{动作2}...'   文件名
条件：
 一般使用关系表达式作为条件，这些关系表达式非常多，例如：
  x>10
动作：
 格式化输出
 流程控制语句
```

格式化输出：

```
#awk '{printf $2 "\t" $6 "\n"}'  student.txt
//输出第二列和第六列
```



**awk条件：**

| 条件类型   | 条件                   | 说明                                                         |
| ---------- | ---------------------- | ------------------------------------------------------------ |
| awk保留字  | BEGIN                  | 在awk程序一开始时，尚未读取任何数据之前执行，BEGIN后的动作旨在程序开始时执行一次 |
|            | END                    | 在awk程序处理完所有数据，即将结束时执行，END后的动作只在程序结束时执行一次 |
| 关系运算符 | >、<、>=、<=、==、!=、 |                                                              |
|            | A~B                    | 判断字符串A中是否包含能匹配B表达式的子字符串                 |
|            | A!~B                   | 判断字符串A中是否不包含能匹配B表达式的子字符串               |
| 正则表达式 | /正则/                 | 如果在“//”中也可以写入字符，也可以支持正则                   |

判断第六字段大于等于87的行，如果判断式成立，则打第二列：

```
# awk '$6 >= 87 {print $2 "\n"}'
as
cs
```

如果第二字段中输入包含有“Sc”字符，则打印第六字段数据：

```
# awk $2 ~ /Sc/ {printf $6 "\n"} sc.txt
```



awk内置变量：

| awk内置变量名 | 作用                                        |
| ------------- | ------------------------------------------- |
| $0            | 代表当前读入行的所有整行数据                |
| $n            | 代表当前读入行的第n个字段                   |
| NF            | 当前行拥有的字段总数                        |
| NR            | 当前awk所处理的行，是总数居的第几行         |
| FS            | 用户定义分隔符，默认分隔符是任何空格        |
| ARGC          | 命令行参数个数                              |
| ARGV          | 命令行参数数组                              |
| FNR           | 当前文件中的当前记录数（对输入文件起始为1） |
| OFMT          | 数值输出格式（默认%. 6g）                   |
| OFS           | 输出字段的分隔符（默认空格）                |
| ORS           | 输出记录分隔符（默认换行符）                |
| RS            | 输入记录分隔符                              |

FS例：

```
# awk '{FS=":"} {printf $1 "\t" $3 "\n"}'
```

NR例：

```
# awk 'BEGIN {FS=":"}  {printf $1 "\t" $3 "\t 行号：" NR "\t 字段数：" NF "\n"}'
```





### 2.2.4 字符串处理之sed

作用：

 用于将数据进行选取，替换，删除，新增的命令，用于程序

命令：

```
# sed [选项] '动作' 文件名
选项：
 -n：只把经过sed命令处理的行输出到屏幕
 -e：允许对输入数据应用多条sed命令编辑
 -f 脚本文件名：从sed脚本中读入sed操作，和awk命令的-f类似
 -r：在sed中支持扩展正则表达式
 -i：用sed的修改结果直接修改读取数据的文件
动作：
 a \:     追加，从当前行后添加一行或多行
 c \:     行替换，用c后面的字符串替换原数据行，替换多行除最后一行外，每行末尾需用“\”代表数据未完结
 i \:     插入，在当前行前插入一行或多行，插入多行跟替换一样
 d:       删除，删除指定行，“2,4d”代表删除第二行到第四行
 p:       打印，输出指定行
 s:       字串替换，用一个字符串替换另外一个字符串，格式
           “行范围s/旧字串/新字串/g”
```

a例：

```
# sed -i '2a 111' sat.txt
在第二行后追加111
```

多条动作执行：

``` 
# sed -e 's/liming//g ; s/t//g' asd.txt
同时把liming和t替换为空
```





### 2.2.5 字符串处理之排序sort

命令：

```
# sort [选项] 文件名
选项：
 -f：忽略大小写
 -b：忽略每行前面的空白部分
 -n：以数值型进行排序，默认字符串型排序
 -r：反向排序
 -u：删除重复行，结束uniq命令（sort -u）
 -t：指定分隔符，默认分隔符是制表符
 -k：指定字段号，“-k 3,3”代表从第三字段开头到第三字段结尾排序，也就是只用第三字段排序
```

统计命令：

```
# wc [选项] 文件名
选项：
 -l：统计行数
 -w：统计单词数
 -m：统计字符数
```



## 2.3 条件判断

### 2.3.1 判断文件类型

test：

```
# test [测试选项]  绝对路径文件名
```

**程序应用**：

```
# [测试选项  绝对路径文件名 ]
```



| 测试选项 |                     作用                     |
| :------: | :------------------------------------------: |
| -b 文件  |      判断文件是否存在且是否为块设备文件      |
| -c 文件  |     判断文件是否存在且是否为字符设备文件     |
| -d 文件  |       判断文件是否存在且是否为目录文件       |
| -e 文件  |              判断该文件是否存在              |
| -f 文件  |       判断文件是否存在且是否为普通文件       |
| -L 文件  |     判断文件是否存在且是否为符号链接文件     |
| -p 文件  |      判断文件是否存在且是否为管道符文件      |
| -s 文件  |    判断文件是否存在且是否为空（非空为真）    |
| -S 文件  | 判断文件是否存在且是否为套接字文件（是为真） |



### 2.3.2 判断文件权限

| 测试选项 |                作用                |
| :------: | :--------------------------------: |
| -r 文件  |  判断文件是否存在且是否拥有读权限  |
| -w 文件  |  判断文件是否存在且是否拥有写权限  |
| -x 文件  | 判断文件是否存在且是否拥有执行权限 |
| -u 文件  | 判断文件是否存在且是否拥有SUID权限 |
| -g 文件  | 判断文件是否存在且是否拥有SGID权限 |
| -k 文件  | 判断文件是否存在且是否拥有SBit权限 |



### 2.3.3 文件比较

|     测试选项      |                          作用                           |
| :---------------: | :-----------------------------------------------------: |
| 文件1  -nt  文件2 |       判断文件1的修改时间是否比文件2新（新为真）        |
| 文件1  -ot  文件2 |       判断文件1的修改时间是否比文件2旧（旧为真）        |
| 文件1  -ef  文件2 | 判断文件1是否和文件2Inode号是否一致，可以认为判断硬链接 |



### 2.3.4 整数比较

|     测试选项      |            作用            |
| :---------------: | :------------------------: |
| 整数1  -eq  整数2 |  判断整数1是否和整数2相等  |
| 整数1  -ne  整数2 | 判断整数1是否和整数2不相等 |
| 整数1  -gt  整数2 |   判断整数1是否大于整数2   |
| 整数1  -lt  整数2 |   判断整数1是否小于整数2   |
| 整数1  -ge  整数2 | 判断整数1是否大于等于整数2 |
| 整数1  -le  整数2 | 判断整数1是否小于等于整数2 |

例：

```
# [50 -ge 40]  && echo  yes  ||  echo no
yes
```





### 2.3.5  字符串判断

|     测试选项      |              作用              |
| :---------------: | :----------------------------: |
|     -z 字符串     | 判断字符串是否为空（为空为真） |
|     -n 字符串     |      判断字符串是否为非空      |
|   字串1 ==字串2   |  判断字符串1是否和字符串2相等  |
| 字串1  !=   字串2 | 判断字符串1是否和字符串2不相等 |



### 2.3.6 多重条件判断（逻辑运算符）

|     测试选项     |                作用                |
| :--------------: | :--------------------------------: |
| 判断1  -a  判断2 |    逻辑与，1和2都成立，结果为真    |
| 判断1  -o  判断2 | 逻辑或，1或2有一个成立，结果就为真 |
|      ! 判断      |               逻辑非               |



## 2.4 if判断

### 2.4.1 单分支

```
if [ 条件判断式 ];then
 程序
fi
```

**注意：**

1. if语句用Fi结尾

2. [ 条件判断式 ]使用test命令判断，**所以中括号和判断式之间必须有空格**

3. then后面跟符合条件之后执行的程序，可以放在[]之后，用“;”分割，或者换行，例如

   ```
   if  [ 条件判断式 ]
       then
        程序
   fi
   ```

    

### 2.4.2 双分支

```
if [ 条件判断式 ]
   then
    成立执行程序
   else
    不成立执行程序
fi
```



 nmap：

```
# nmap  [选项]  ip地址
选项：
 -s：扫描
 -T：扫描所有开启的tcp端口
```



### 2.4.3 多分支

```
if [ 条件判断式 ]
   then
    判断1成立执行程序
elif [ 条件判断式 ]
   then
    判断2成立执行程序
else
   不成立执行程序 
fi
```





## 2.5 case多分支

```  
case $变量名 in
  "变量值1")
       如果变量名为变量值1，则执行程序1
       ;;
  "变量值2")
       如果变量名为变量值2，则执行程序2
       ;;
   ...省略...
         *)
       如果变量的值都不是以上值，则执行此程序
       ;;
esac
```





## 2.6 for循环

### 2.6.1 for语法

语法1：

```
for 变量 in 值1 值2 值3...
 do
  程序
 done
```

解释：有几个值将几个值的值代入变量，决定循环次数，适合运维脚本



语法2：

```
for ((初始值;循环控制条件;变量变化))
 do
  程序
 done
```





### 2.6.2 批量解压缩

语法2：

```
#!/bin/bash

cd/root/sh/tar

ls *.tar.gz > tar.log 
//将后缀为tar.gz的文件名写入tar.log

ls *.tgz >> tar.log &> /dev/null

aa=$(cat /root/sh/tar.log|wc -l)
//统计tar.log文件里的压缩包名个数

for((i=1;i<=$aa;i=i+1))
 do
  bb=$(cat tar.log | awk 'NR=='$i' {print $1}')
  //NR指定行后，输出第一列，tar.log只有一列
      adsfasdf.tar.gz
  tar -zxvf $bb -C /root/sh/tar
 done
```

语法1：

```
#!/bin/bash
cd/root/sh/tar
ls *.tar.gz > tar.log 
ls *.tgz >> tar.log &> /dev/null
for i in $(cat tar.log)  //文件有六个文件名循环了六次
 do
  tar -zxvf $i
 done
```



### 2.6.3 合法ip地址判断

```
#!/bin/bash
grep "^[0-9]\{1,3\}\.[0-9]\{1,3}\.[0-9]\{1,3\}$"  /root/sh/ip.txt > /root/sh/ipt.txt
//通过正则将不符合的过滤掉，保存到临时文件
echo "" > /root/sh/ipv.txt
//清空保存数据的文件
for i in $(cat /root/sh/ipt/txt)
 do
  a=$(echo "$i" | cut -d "." -f 1)
  b=$(echo "$i" | cut -d "." -f 2)
  c=$(echo "$i" | cut -d "." -f 3)
  d=$(echo "$i" | cut -d "." -f 4)
  //将ip地址的四个数值分别读入变量
  if ["$a" -lt 1 -o "$a" -gt 255]
  //如果第一个数值大于1火大于等于255
   then
    continue //退出本次循环
  fi
  
  if ["$b" -lt 1 -o "$b" -gt 255]
   then
    continue //退出本次循环
  fi
  
  if ["$c" -lt 1 -o "$c" -gt 255]
   then
    continue //退出本次循环
  fi
  
  if ["$d" -lt 1 -o "$d" -gt 255]
   then
    continue //退出本次循环
  fi
  
  echo "$i" >> /root/sh/ipv.txt
  //合法ip地址写入ipv文件
 done
```



### 2.6.4 批量添加用户

```
#!/bin/bash

read -p "Please input user name:" -t 30 name
read -p "Please input the number:" -t 30 num
read -p "Please input user password:" -t 30 pass

if [! -z "$name" -a ! -z "$num" -a ! -z "$pass"]
//判断三个变量不为空
 then
   y=$(echo $num | sed 's/[0-9]/g')
   //将num值替换为空，证明num值为数字
   if [-z "$y"]
    then
     for ((i=1;i<=$num;i=i+1))
      do
        /usr/sbin/useradd $name$i &>/dev/null
        //添加用户并将输出丢弃null
        echo $pass | /usr/bin/passwd --stdin $name$i &>/dev/null
        chage -d 0 $name$i &> /dev/null
        //强制用户登录后修改密码
      done
     fi
  fi    
```

### 2.6.5 批量删除用户

```
#!/bin/bash
name=$(cat /etc/passwd | grep "/bin/bash" | gre[ -v root | cut -d ":" -f 1)

for i in $name
do
 userdel -r $i
done
```



## 2.7 while循环

语法：

```
while [ 条件判断式 ]
 do
  程序
  i=$(($i+1))
 done
```



## 2.8 until循环

语法：

```
until [ 条件判断式 ]
 do
  程序
  i=$(($i+1))
 done
```

**与while相反，只在条件判断式不成立下循环**

## 2.8 exit语句

系统exit命令式用于退出用户登录状态，而shell脚本里的**特殊流程控制语句exit**用于退出脚本

语法：

```
eixt [返回值]
```

如果exit命令定义了返回值，这个脚本执行后的返回值就是自己定义的，通过$?查询，如果没有定义，脚本执行之后的返回值式执行exit1语句之前最后执行的一条命令的返回值



## 2.7 break和continue

**break：跳出整个循环**

```
#!/bin/bash
for((i=1;i<=5;i=i+1))
do
 if ["$i"=4]
  then
   break
 fi
 echo $i
done

1
2
3
```

**continue：跳出本次循环**

```
#!/bin/bash
for((i=1;i<=5;i=i+1))
do
 if ["$i"=4]
  then
   continue
 fi
 echo $i
done

1
2
3
5

```

